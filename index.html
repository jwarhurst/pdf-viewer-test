<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <!-- For mobile, user-scalable remains disabled; adjust as needed -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Text</title>
  <!-- Use pdf_viewer.min.css from cdnjs -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #eee;
    }
    #pdf-container {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      position: relative;
      padding: 20px;
      box-sizing: border-box;
    }
    #pdf-inner {
      transform-origin: 0 0;
      position: relative;
    }
    .pageContainer {
      position: relative;
      margin: 0 auto 20px;
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    canvas {
      display: block;
    }
    .textLayer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      color: transparent;
      text-shadow: 0 0 0 black;
    }
  </style>
</head>
<body>
  <div id="pdf-container">
    <div id="pdf-inner"></div>
  </div>

  <!-- Load pdf.js, pdf_viewer, and Hammer.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>
    // Version info
    const appVersion = 'v3.11.174-test-2025-01-31';
    console.log('App Version:', appVersion);

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    const pdfUrl = 'dummy.pdf';
    const pdfContainer = document.getElementById('pdf-container');
    const pdfInner = document.getElementById('pdf-inner');
    let currentScale = 1; // Will be computed based on first page width
    const minScale = 0.5;
    const maxScale = 3;
    const containerPadding = 20; // Padding value

    // Variables for handling pinch
    let originalWidth, originalHeight;
    let initialPinchScale = 1;
    let initialScrollLeft = 0, initialScrollTop = 0;
    let pinchCenterX = 0, pinchCenterY = 0;

    // Load PDF and compute initial scale.
    pdfjsLib.getDocument(pdfUrl).promise.then(pdf => {
      pdf.getPage(1).then(page => {
        const firstViewport = page.getViewport({ scale: 1 });
        const innerWidth = pdfContainer.clientWidth - (containerPadding * 2);
        currentScale = innerWidth / firstViewport.width;
        pdfInner.style.transform = `scale(${currentScale})`;
        originalWidth = firstViewport.width;
        originalHeight = firstViewport.height;
        pdfInner.style.width = (originalWidth * currentScale) + 'px';
        pdfInner.style.height = (originalHeight * currentScale) + 'px';
        // Note: Since the container already has padding, we don't offset pdfInner.

        // Now load all pages.
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          pdf.getPage(pageNum).then(page => {
            const viewport = page.getViewport({ scale: 1 });
            const pageContainer = document.createElement('div');
            pageContainer.className = 'pageContainer';
            pageContainer.style.width = viewport.width + 'px';
            pageContainer.style.height = viewport.height + 'px';
            
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const context = canvas.getContext('2d');
            pageContainer.appendChild(canvas);
            
            const textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            textLayerDiv.style.width = viewport.width + 'px';
            textLayerDiv.style.height = viewport.height + 'px';
            textLayerDiv.style.setProperty('--scale-factor', viewport.scale);
            pageContainer.appendChild(textLayerDiv);
            
            pdfInner.appendChild(pageContainer);
            
            page.render({ canvasContext: context, viewport: viewport });
            page.getTextContent().then(textContent => {
              pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport: viewport.clone({ dontFlip: true }),
                textDivs: []
              }).promise.then(() => {
                console.log(`Text layer rendered for page ${pageNum}`);
              });
            });
          });
        }
      });
    });

    pdfContainer.addEventListener('touchstart', function(e) {
      if (e.touches.length > 1) { e.preventDefault(); }
    }, { passive: false });

    // Set up Hammer.js for pinch-to-zoom.
    const hammer = new Hammer(pdfContainer, { touchAction: 'auto' });
    hammer.get('pinch').set({ enable: true });
    hammer.on('pinchstart', (ev) => {
      initialPinchScale = currentScale;
      initialScrollLeft = pdfContainer.scrollLeft;
      initialScrollTop = pdfContainer.scrollTop;
      const rect = pdfContainer.getBoundingClientRect();
      pinchCenterX = ev.center.x - rect.left;
      pinchCenterY = ev.center.y - rect.top;
      pdfInner.style.transformOrigin = `${pinchCenterX}px ${pinchCenterY}px`;
    });
    // During pinch, just update the scale visually.
    hammer.on('pinch', (ev) => {
      let newScale = initialPinchScale * ev.scale;
      if (newScale < minScale) newScale = minScale;
      if (newScale > maxScale) newScale = maxScale;
      currentScale = newScale;
      
      // Update transform immediately
      pdfInner.style.transform = `scale(${currentScale})`;
      pdfInner.style.width = (originalWidth * currentScale) + 'px';
      pdfInner.style.height = (originalHeight * currentScale) + 'px';
      
      // Compute how much the scale has changed relative to pinch start.
      const scaleRatio = currentScale / initialPinchScale;
      // Adjust scroll offsets continuously so the pinch center stays anchored.
      pdfContainer.scrollLeft = initialScrollLeft + (scaleRatio - 1) * pinchCenterX;
      pdfContainer.scrollTop  = initialScrollTop  + (scaleRatio - 1) * pinchCenterY;
    });
    // On pinchend, update the scroll offsets to keep the pinch center anchored.
    hammer.on('pinchend', (ev) => {
      // Calculate relative offsets.
      const scaleRatio = currentScale / initialPinchScale;
      pdfContainer.scrollLeft = initialScrollLeft + (scaleRatio - 1) * pinchCenterX;
      pdfContainer.scrollTop  = initialScrollTop  + (scaleRatio - 1) * pinchCenterY;
    });
  </script>
</body>
</html>
