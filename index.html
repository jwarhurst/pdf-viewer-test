<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <!-- Disable native pinch zoom -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Text</title>
  <!-- Use pdf_viewer.min.css from cdnjs -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #eee;
    }
    #pdf-container {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      position: relative;
      padding: 20px;
    }
    #pdf-inner {
      transform-origin: 0 0;
      position: relative;
    }
    .pageContainer {
      position: relative;
      margin: 0 auto 20px;
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    canvas {
      display: block;
    }
    .textLayer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      color: transparent;
      text-shadow: 0 0 0 black;
    }
  </style>
</head>
<body>
  <div id="pdf-container">
    <div id="pdf-inner"></div>
  </div>

  <!-- Load pdf.js, pdf_viewer, and Hammer.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>
    const appVersion = 'v3.11.174-test-2025-01-31';
    console.log('App Version:', appVersion);

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    const pdfUrl = 'dummy.pdf';
    const pdfContainer = document.getElementById('pdf-container');
    const pdfInner = document.getElementById('pdf-inner');
    let currentScale = 1; // Computed based on first page
    const minScale = 0.5;
    const maxScale = 3;
    const containerPadding = 20;

    let originalWidth = 0, originalHeight = 0;

    // Variables for pinch handling.
    let initialPinchScale = currentScale;
    let initialScrollLeft = 0, initialScrollTop = 0;
    let pinchCenterX = 0, pinchCenterY = 0;

    // Load PDF and compute initial scale.
    pdfjsLib.getDocument(pdfUrl).promise.then(pdf => {
      pdf.getPage(1).then(page => {
        const firstViewport = page.getViewport({ scale: 1 });
        originalWidth = firstViewport.width;
        originalHeight = firstViewport.height;
        // Compute inner width: subtract container padding on both sides.
        const innerWidth = pdfContainer.clientWidth - (containerPadding * 2);
        currentScale = innerWidth / firstViewport.width;
        pdfInner.style.transform = `scale(${currentScale})`;
        pdfInner.style.width = (originalWidth * currentScale) + 'px';
        pdfInner.style.height = (originalHeight * currentScale) + 'px';

        // Load all pages.
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          pdf.getPage(pageNum).then(page => {
            const viewport = page.getViewport({ scale: 1 });
            const pageContainer = document.createElement('div');
            pageContainer.className = 'pageContainer';
            pageContainer.style.width = viewport.width + 'px';
            pageContainer.style.height = viewport.height + 'px';
            
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const context = canvas.getContext('2d');
            pageContainer.appendChild(canvas);
            
            const textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            textLayerDiv.style.width = viewport.width + 'px';
            textLayerDiv.style.height = viewport.height + 'px';
            textLayerDiv.style.setProperty('--scale-factor', viewport.scale);
            pageContainer.appendChild(textLayerDiv);
            
            pdfInner.appendChild(pageContainer);
            
            page.render({ canvasContext: context, viewport: viewport });
            page.getTextContent().then(textContent => {
              pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport: viewport.clone({ dontFlip: true }),
                textDivs: []
              }).promise.then(() => {
                console.log(`Text layer rendered for page ${pageNum}`);
              });
            });
          });
        }
      });
    });

    pdfContainer.addEventListener('touchstart', function(e) {
      if (e.touches.length > 1) { e.preventDefault(); }
    }, { passive: false });

    // Animate scroll offsets to smooth the final adjustment.
    function animateScroll(targetLeft, targetTop, duration = 200) {
      const startLeft = pdfContainer.scrollLeft;
      const startTop = pdfContainer.scrollTop;
      const deltaLeft = targetLeft - startLeft;
      const deltaTop = targetTop - startTop;
      const startTime = performance.now();

      function step(now) {
        const elapsed = now - startTime;
        const progress = Math.min(elapsed / duration, 1);
        pdfContainer.scrollLeft = startLeft + deltaLeft * progress;
        pdfContainer.scrollTop = startTop + deltaTop * progress;
        if (progress < 1) {
          requestAnimationFrame(step);
        }
      }
      requestAnimationFrame(step);
    }

    // Set up Hammer.js for pinch-to-zoom.
    const hammer = new Hammer(pdfContainer, { touchAction: 'auto' });
    hammer.get('pinch').set({ enable: true });
    
    hammer.on('pinchstart', (ev) => {
      initialPinchScale = currentScale;
      initialScrollLeft = pdfContainer.scrollLeft;
      initialScrollTop = pdfContainer.scrollTop;
      const rect = pdfContainer.getBoundingClientRect();
      // Calculate pinch center relative to container.
      pinchCenterX = ev.center.x - rect.left + pdfContainer.scrollLeft;
      pinchCenterY = ev.center.y - rect.top + pdfContainer.scrollTop;
      pdfInner.style.transformOrigin = `${pinchCenterX}px ${pinchCenterY}px`;
    });
    
    // During pinch: update transform continuously.
    hammer.on('pinch', (ev) => {
      let newScale = initialPinchScale * ev.scale;
      if (newScale < minScale) newScale = minScale;
      if (newScale > maxScale) newScale = maxScale;
      currentScale = newScale;
      pdfInner.style.transform = `scale(${currentScale})`;
    }
