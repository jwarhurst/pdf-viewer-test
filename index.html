<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8" />
  <!-- For mobile, user-scalable remains disabled; adjust as needed -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Text</title>
  <!-- Use pdf_viewer.min.css from cdnjs -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.css" />
  <style>
    html, body {
      height: 100%;
      margin: 0;
      overflow: hidden;
      background-color: #eee;
    }
    #pdf-container {
      height: 100%;
      overflow: auto;
      -webkit-overflow-scrolling: touch;
      position: relative;
      padding: 20px;
      box-sizing: border-box;
    }
    #pdf-inner {
      transform-origin: 0 0;
      position: relative;
      /* We'll update its explicit width/height on zoom */
    }
    .pageContainer {
      position: relative;
      margin: 0 auto 20px;
      background-color: #fff;
      border: 1px solid #ccc;
      box-shadow: 0 2px 5px rgba(0,0,0,0.2);
    }
    canvas {
      display: block;
    }
    .textLayer {
      position: absolute;
      top: 0;
      left: 0;
      pointer-events: auto;
      -webkit-user-select: text;
      -moz-user-select: text;
      -ms-user-select: text;
      user-select: text;
      color: transparent;
      text-shadow: 0 0 0 black;
    }
  </style>
</head>
<body>
  <div id="pdf-container">
    <div id="pdf-inner"></div>
  </div>

  <!-- Load pdf.js, pdf_viewer, and Hammer.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf_viewer.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/hammer.js/2.0.8/hammer.min.js"></script>
  <script>
    // Version info
    const appVersion = 'v3.11.174-test-2025-01-31';
    console.log('App Version:', appVersion);

    pdfjsLib.GlobalWorkerOptions.workerSrc =
      'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/3.11.174/pdf.worker.min.js';
    const pdfUrl = 'dummy.pdf';
    const pdfContainer = document.getElementById('pdf-container');
    const pdfInner = document.getElementById('pdf-inner');
    let currentScale = 1; // Will be computed based on first page width

    // Define min and max scale values (optional)
    const minScale = 0.5;
    const maxScale = 3;

    // Variables for dynamic scroll handling during pinch
    let originalWidth, originalHeight;
    let initialPinchScale = 1;
    let initialScrollLeft = 0, initialScrollTop = 0;

    // Load the PDF and then compute initial scale based on the first page.
    pdfjsLib.getDocument(pdfUrl).promise.then(pdf => {
      // Get the first page to compute initial scale.
      pdf.getPage(1).then(page => {
        const firstViewport = page.getViewport({ scale: 1 });
        // Compute scale so first page fits container width (ignoring padding)
        currentScale = pdfContainer.clientWidth / firstViewport.width;
        // Apply initial transform.
        pdfInner.style.transform = `scale(${currentScale})`;
        // Set the scrollable area explicitly using the unscaled dimensions.
        // We'll assume that pdfInner's unscaled dimensions equal the size of the first page container.
        originalWidth = firstViewport.width;
        originalHeight = firstViewport.height;
        // (If there are multiple pages of varying sizes, you might compute a bounding box instead.)
        pdfInner.style.width = (originalWidth * currentScale) + 'px';
        pdfInner.style.height = (originalHeight * currentScale) + 'px';

        // Now load all pages.
        for (let pageNum = 1; pageNum <= pdf.numPages; pageNum++) {
          pdf.getPage(pageNum).then(page => {
            const viewport = page.getViewport({ scale: 1 });
            const pageContainer = document.createElement('div');
            pageContainer.className = 'pageContainer';
            pageContainer.style.width = viewport.width + 'px';
            pageContainer.style.height = viewport.height + 'px';
            
            const canvas = document.createElement('canvas');
            canvas.width = viewport.width;
            canvas.height = viewport.height;
            const context = canvas.getContext('2d');
            pageContainer.appendChild(canvas);
            
            const textLayerDiv = document.createElement('div');
            textLayerDiv.className = 'textLayer';
            textLayerDiv.style.width = viewport.width + 'px';
            textLayerDiv.style.height = viewport.height + 'px';
            textLayerDiv.style.setProperty('--scale-factor', viewport.scale);
            pageContainer.appendChild(textLayerDiv);
            
            pdfInner.appendChild(pageContainer);
            
            page.render({ canvasContext: context, viewport: viewport });
            
            page.getTextContent().then(textContent => {
              pdfjsLib.renderTextLayer({
                textContentSource: textContent,
                container: textLayerDiv,
                viewport: viewport.clone({ dontFlip: true }),
                textDivs: []
              }).promise.then(() => {
                console.log(`Text layer rendered for page ${pageNum}`);
              });
            });
          });
        }
      });
    });

    pdfContainer.addEventListener('touchstart', function(e) {
      if (e.touches.length > 1) { e.preventDefault(); }
    }, { passive: false });

    // Set up Hammer.js for pinch-to-zoom.
    const hammer = new Hammer(pdfContainer, { touchAction: 'auto' });
    hammer.get('pinch').set({ enable: true });
    hammer.on('pinchstart', (ev) => {
      // Store the initial scale and scroll offsets.
      initialPinchScale = currentScale;
      initialScrollLeft = pdfContainer.scrollLeft;
      initialScrollTop = pdfContainer.scrollTop;
      // (Optionally, update the transformOrigin here as well.)
      const rect = pdfContainer.getBoundingClientRect();
      const originX = ev.center.x - rect.left + pdfContainer.scrollLeft;
      const originY = ev.center.y - rect.top + pdfContainer.scrollTop;
      pdfInner.style.transformOrigin = `${originX}px ${originY}px`;
    });
    hammer.on('pinch', (ev) => {
      let newScale = initialPinchScale * ev.scale;
      if (newScale < minScale) newScale = minScale;
      if (newScale > maxScale) newScale = maxScale;
      currentScale = newScale;
      pdfInner.style.transform = `scale(${currentScale})`;
      // Update the explicit dimensions of pdfInner so that the container's scroll area grows.
      pdfInner.style.width = (originalWidth * currentScale) + 'px';
      pdfInner.style.height = (originalHeight * currentScale) + 'px';
      
      // Adjust scroll offsets to maintain the same relative position:
      // Calculate relative scroll from pinchstart.
      const relativeLeft = initialScrollLeft / (originalWidth * initialPinchScale);
      const relativeTop = initialScrollTop / (originalHeight * initialPinchScale);
      pdfContainer.scrollLeft = relativeLeft * (originalWidth * currentScale);
      pdfContainer.scrollTop = relativeTop * (originalHeight * currentScale);
    });
  </script>
</body>
</html>
